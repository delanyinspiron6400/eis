%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass[a4paper, 10 pt, conference]{ieeeconf}
\usepackage{stylesheet}



%-----------------------------------------------------------
%-
%-  Titel
%-
%-----------------------------------------------------------
\title{\LARGE \bf Summary of ``Einführung in die Informationssicherheit''}

%-----------------------------------------------------------
%-
%-  Authors
%-
%-----------------------------------------------------------
\author{Martin Winter}

%-----------------------------------------------------------
%-
%-  References in references.bib
%-
%-----------------------------------------------------------

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

\maketitle
\thispagestyle{empty}
\pagestyle{empty}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%-----------------------------------------------------------
%-
%-  abstract
%-
%-----------------------------------------------------------
\begin{abstract}

This document should serve as a summary of the necessary information given in the lecture ``Einführung in die Informationssicherheit''

\end{abstract}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%-----------------------------------------------------------
%-
%-  Introduction
%-
%-----------------------------------------------------------
\section{ABBREVIATIONS and STANDARD NOTATION}
\begin{table}[h!]
    \begin{center}
    \begin{tabularx}{\columnwidth}{c c} % right-aligned, column separation by =-sign (and some whitespace to the left and to the right), left-aligned, centered, siunit: aligned at comma
        \toprule
       Abbreviation & Notation \\
        \midrule
        AES & Advanced Encryption Standard \\
        CBC & Cipher Block Chaining mode \\
        CFB & Cipher FeedBack mode\\
        CRL & Certificate Revocation List\\
        DES & Data Encryption Standard \\
        DHP & Diffie-Hellman problem \\
        DLP & Discrete logarithm problem \\
        DN & Distinguished Name \\
        DPA & Differential Power Analysis \\
        DSA & Digital Signature Algorithm \\
        ECB & Electronic Codebook mode \\
        ECDLP & Elliptic Curve Discrete Logarithm Problem \\
        ECDSA & Elliptic Curve Digital Signature Algorithm \\
        GDLP & Generlized discrete Logarithm Problem \\
        HW & Hamming Weight \\
        IDS & Intrusion Detection System \\
        IFP & Integer Factorization Problem \\
        LSB & Least Significant Bit \\
        MAC & Message Authentication Code \\
        MDC & Modification Detection Code \\
        MSB & Most Significant Bit \\
        OFB & Output Feedback mode \\
        OID & Object Identifier \\
        PGP & Pretty Good Privacy \\
        PKI & Public Key Infrastructure \\
        RSA & Rivest-Shamir-Adleman encryption scheme \\
        SCA & Side-Channel Attack \\
        SPA & Simple Power Analysis \\
        SSCA & Simple Side-Channel Attack \\
        DSCA & Differential Side-Channel Attack \\
        \bottomrule
    \end{tabularx}
    \end{center}
\end{table}

\pagebreak


%-----------------------------------------------------------
%-
%-  BASIC CRYPTOLOGIC PRINCIPLES
%-
%-----------------------------------------------------------

\section{\textbf{BASIC CRYPTOLOGIC PRINCIPLES}}
Because of the rise of digital communication, the value of information keeps growing, while it is subject to a large number of threats. 
This brings up the need to protect this information, hence Cryptography is the science of protecting information. 
A \textbf{cryptographic algorithm} is a \textbf{mathematical function}, that uses a \textbf{key} to encipher information, without this key, deciphering wouldn't be possible. 
\subsection{\textbf{CIA and Non-repudiation}}
Typically two entities want to \textbf{exchange messages securely} over an \textbf{insecure channel}, the \textbf{adversary} can now try to do several things, including eavesdropping the communication or altering it. 
\textbf{Eavesdropping} (Abhören) is a threat to the \textbf{confidentiality} of the message, a third member could possible read the content of the message. 
On the other hand, \textbf{altering} (Verändern) is a threat to the \textbf{integrity} of the message, therefore it is required to \textbf{authenticate} the communicating entities. 
The last of the security service deals is called \textbf{non-repudiation} (Nicht-Anerkennung), which means, that a sender cannot deny a message was sent, this property cannot be achieved by secret key cryptography alone unfortunately. 

\subsection{\textbf{Secret Key Cryptography}}
The most important requirement for such algorithms, besides their resistance against attacks, is that the reduction of performance is minimal. There are three types, which are discussed here
\begin{itemize}
\item \textbf{Block Ciphers} : Used to Encrypt Data
\item \textbf{Stream Ciphers} : Used as alternative
\item \textbf{MDCs}: Ensure integrity of data
\item \textbf{MACs}: For authentication
\end{itemize}

\vspace{0.5cm}

\subsubsection{\textbf{Block Ciphers}}
are defined as a set of boolean permutations on a \emph{n-bit} vector, this set contains a boolean permutation for each value of a key \emph{k}. 
It takes an element (from plaintext) and transforms it into an element from ciphertext.
Such a block cipher usually consists of several transformations, which form the encryption algorithm, those transformations happen several times, the transformation itself is called \emph{round function}, for each round a \emph{round key} $K_i$ is generated from the cipher key. 
There are mainly two different types of design, the \emph{Feistel ciphers} and the \emph{substitution permutation network (SPN)}. \\
There are also several modes of operation, whenever a message is longer than the block size, four modes are standardized. 
The \emph{electronic code book} (ECB) corresponds to the usual use case, the message is split into blocks and each block is encrypted separately with the same key. \\
In \emph{cipher block chaining} (CBC) each ciphertext block is x-ored with the next plaintext block before encryption. \\
In the \emph{output feedback} (OFB) mode and the \emph{cipher feedback} (CFB) mode, a keystream is generated and x-ored with the plaintext.

\subsubsection{\textbf{Stream Ciphers}} 
encrypt individual characters, usually bits, of a plaintext one at a time and use an encryption transformation, which varies with time. 
In contrast to block ciphers, this encryption not only depends on the key and plaintext, but also on the current state. \\
\textbf{Synchronous} stream ciphers generate a keystream independently of the plaintext, sender and receiver must therefore be synchronized (same key and same state within that key). \\
\textbf{Asynchronous} stream cipher is a stream cipher, in which the keystream is generated as a function of the key and a fixed number of previous ciphtertext bits. 
Because the keystream is dependent on only a few previous ciphertext bits, self-synchronization is possible even if some of the transmitted ciphertext bits are corrupted. 

\subsubsection{\textbf{MDCs}} 
take an input of arbitrary length and compress it to an output of fixed length, which is called the hash value. 
It satisfies the following properties
\begin{itemize}
\item \emph{preimage resistance}: computationally infeasible to find preimage to given hash value
\item \emph{2nd preimage resistance}: computationally infeasible to find 2nd preimage
\item \emph{collision resistance}: computationally infeasible to find two different inputs with same hash value
\end{itemize}
Hash functions are used to ensure the integrity of data, data is used as input to the hash function and the output is stored. It is possible to check the input for alteration by simply redoing the computation and comparing it with the original hash value. 

\subsubsection{\textbf{MACs}}
Hash functions, which involve a secret key, are called MACs (message authentication codes). The output of such a \emph{keyed hash function} is also called MAC, in contrast to MDCs they can also guarantee \textbf{data origin authentication} and \textbf{data integrity}. 
In order to ensure authenticity of data, an entity computes a MAC on the data using a private key, to verify the authenticity of the data later on, the MAC can be recomputed using the private key. 

\subsection{\textbf{Public Key Cryptography}}
In public key cryptography, secret keys are \textbf{replaced by keypairs}, consisting of a \textbf{private key}, which must be kept confidential, and a \textbf{public key}, which is openly accessible. \\
A message, encrypted by the public key, can be decrypted by the private key, this works, because the keys are linked in a mathematical way, such that knowing the public key does not allow to recover the private key, but enable independent encryption/decryption. 
\vspace{0.5cm}
\subsubsection{\textbf{RSA}}
\label{ex:rsa}
The Rivest-Shamir-Adleman(RSA) algorithm was the first public key encryption algorithm invented. It is based on IFP (Integer factorization problem) and keys are generated as follows: \\
One selects two large, \textbf{secret prime numbers} $p$ and $q$ and computes the public RSA modules
\begin{equation*}
n = p \cdot q
\end{equation*}
Then one chooses a public encryption exponent $e$ wich satisfies 
\begin{equation*}
gcd \left(e, (p-1)(q-1)\right) = 1 
\end{equation*}
gcd stands for \emph{greatest common divisor}. The private key $d$ can be calculated by solving
\begin{equation*}
e \cdot d = 1 \ mod \ (p-1)(q-1)
\end{equation*}
Hence the \textbf{public key} is the \textbf{pair (e,n)} and the \textbf{private key} is the \textbf{triple (d,p,q)}.\\
For encryption, the message needs to represented as a number $m < n$, the ciphtertext itself is computed by raising $m$ to the power of $e$
\begin{equation*}
c = m^{e} \ mod \ n
\end{equation*}
The message can be decrypted by exponentiation like
\begin{equation}
m  = c^{d} \ mod \ n
\end{equation}
\textbf{Example Key Generation}: \\
In real applications, p and q should at least be 512 bits!
\begin{align*}
p = 5 \quad q = 11 \\
n = p \cdot q = 55 \\
(p-1)(q-1) = 40 \\
\text{Random Number }e = 7 \\
gcd(e,(p-1)(q-1)) = 1 \\
d = e^{-1} \equiv 23 \ mod \ 40
\end{align*}
The public key is now $(e,n) = (7,55)$ and the private key is $(d,n) = (23,55)$. \\
\textbf{Example Encryption}: \\
\label{ex:rsa}
Encrypt the message M, assuming $M=25$ with public key $(e,n) = (7,55)$. 
\begin{equation*}
c = 25 ^{7} \equiv 20 \ mod \ n
\end{equation*}
\textbf{Example Decryption}: \\
Received message is $c = 20 \ mod \ 55$ and private key is $(d,n) = (23,55)$. This leads to 
\begin{equation*}
m = 20^{23} \equiv 25 \ mod \ 55
\end{equation*}

\vspace{0.5cm}
\subsubsection{\textbf{El Gamal}}

The El Gamal encryption algorithm is based on the DLP, and some public parameters can be shared by a group of users, called \emph{domain parameters}. This parameter is a \textbf{large prime p} (such that $p-1$ is divisible by another prime $q$) and an element $q \in \mathbb{Z}^{*}_{p}$ of order $p$ (or that the order is divisible by $q$. The \textbf{private key} $e$ can then be computed by solving
\begin{equation*}
e = g^{d} \ mod \ p
\end{equation*}

\textbf{Example Key Generation}: \\
In real applications, p should at least be 1024 bits!
\begin{align*}
p = 41 \quad g = 6 \quad d = 17 \\
e := g^{d} = 6^{17} \equiv 26 \ mod \ 41
\end{align*}
The private key $d$ is a random number between 2 and $p-1$. \\
\textbf{Example Encryption}: \\
Encrypt the message M, assuming $M=55$ with public key $(e,p,g) = (26,41,6)$. Then, use random number $k=11$ and compute 
\begin{align*}
c_1 = g^{k} = 6^{11} \equiv 28 \ mod \ 41 \\
c_2 = m\cdot e^{k} = 526^{11} \equiv 19 \ mod \ 41
\end{align*}
The encrypted message $(c_1,c_2) = (28,41)$ is now sent. 
\textbf{Example Decryption}: \\
Received message is $(c_1,c_2) = (28,41)$ and private key is $(d,p,g) = (17,41,6)$. This leads to 
\begin{equation*}
\frac{c_2}{c_1^{d}} = \frac{41}{28^{17}} \equiv 5 \ mod \ 41
\end{equation*}

\subsubsection{\textbf{ECC}}
ECC (Elliptic Curve)is a smooth curve in the so called \emph{Weierstrassform}. 
Similar to the El Gamal cryptosystem, several public parameters can be shared among a group of users.
These parameters are the elliptic curve group itself and the base point, the \textbf{private key} is a chosen integer $d$ and the public key is given by $e=dB$. 

\vspace{0.5cm}
\subsubsection{\textbf{Key Agreement}}
A major disadvantage of symmetric key cryptography is, that secret keys need to be distributed securely to the users. This problem can be solved using public key cryptography.


\vspace{0.5cm}
\subsubsection{\textbf{Digital Signatures}}
A digital signature is the equivalent of a handwritten signature, it binds someone's identity to a piece of information. A digital signature scheme consists of a \textbf{signature creation algorithm} and an associated \textbf{signature verification algorithm}. \\
Digital signatures \emph{with appendix} require the original message as input to the verification algorithm, digital signatures \emph{with message recovery} \textbf{do not} require the original message as input, it is recovered from the signature itself. 

The \textbf{DSS} is a standardized signatures scheme with appendix, which describes an algorithm called \textbf{DSA} (Digital Signature Algorithm) based on DLP, it has recently been extended and is now based on elliptic curves. \\
In order to sign a message, the owner first computes the hash value of the message, this value and the private key are then fed to the signing algorithm. 
The output is a signature of the input message, anyone who wishes to verify the signature can simply take the message, the public key and the signatures and compute the verification algorithm. 

\subsection{\textbf{Security and Attacks}} 
There exist many different types of attacks on cryptographic primitives, usually the goal is to deduce the secret key. \\
A \textbf{passive attack} is one, where the adversary only monitors the communication channel or the side-channels of the communication devices, they target the implementation, not the algorithm itself. \\
An \textbf{active attack} is one, where the adversary attempts to alter the transmission on the channel or the computation inside the device (\emph{fault attacks}). 
Side-channel attacks and fault attacks are so called \textbf{implementation attacks}, which pose a serious threat to cryptographic systems. 
To classify attacks, an assumption is made, that the adversary knows all details, except for the secret key. 
\begin{itemize}
\item \textbf{ciphertext-only}: deduce secret key by only observing ciphertext
\item \textbf{known-plaintext}: adversary has number of plaintext and corresponding ciphertexts
\item \textbf{chosen-plaintext}: adversary chooses plaintext and is given corresponding chiphertext
\item \textbf{adaptive chosen-plaintext}: choice of plaintext may depend on previous chipertexts
\item \textbf{chosen-ciphertext}: adversary chooses the ciphertext and is given the corresponding plaintext
\item \textbf{adaptive chosen-ciphertext}: choice of ciphertext may depend on previous plaintexts
\end{itemize}
Encryption schemes, which are vulnerable to ciphertext-only attacks, are considered completely insecure. 

\vspace{0.5cm}
\subsubsection{\textbf{Security Models}}
There are several different models, under which the security of a cryptograhpic primitive can be evaluated. 
\label{ex:secmod}
\begin{itemize}
\item \textbf{Unconditional security}: In this model, the adversary is assumed to have unlimited computational power, so this model is also called \emph{perfect secrecy}. A necessary condition is, that the secret key is at least as long as the message, because of that, systems like that are impractical. 
\item \textbf{Computational security}: Adversaries are assumed to have polynomial computational power, an algorithm is considered to be secure, if the best algorithm for breaking requires superpolynomial or exponential number of steps. 
\item \textbf{Provable security}: A cipher has provable security, if the difficulty of breaking can be shown to be equivalent to solving a well known, hard mathematical problem like DLP. 
\item \textbf{Practical security}: It is also related tot he computational power of the adversary, a cipher is considered practically secure, if the best \emph{known} attack requires at least $N$ operations, where $N$ is a sufficiently large number. 
\end{itemize}

\pagebreak 
\subsection{\textbf{Review Exercises}}

\subsubsection{\textbf{Name and explain the four security services (properties) cryptography can provide!}}
\begin{itemize}
\item confidentiality: "no unintended third party can understand the content"
\item integrity: "no one can change the message while it is in transit"
\item authentication: "get assurance of identity"
\item non-repudiation: "sender cannot deny a message was sent"
\end{itemize}

\subsubsection{\textbf{What is Kerckhoffs' principle?}}
The adversary knows all details about the used algorithms and protocols, only the secret key is unknown. 

\subsubsection{\textbf{What are the basic components of a block cipher?}}
The block cipher is a mathematical function, which takes plaintext as input, separates it into blocks, encrypts those with the secret key and has as output the ciphertext. 
Examples are DES (Data Encryption Standard) and AES (Advanced Encrpytion Standard). 

\subsubsection{\textbf{What is the difference between a block cipher and a stream cipher?}}
A block cipher encrypts blocks of data using a function dependent on the key, while a stream cipher generates a bitstream from the key and XORs it with the data. 

\subsubsection{\textbf{What is the difference between a MAC and an MDC?}}
MAC (Message Authentication Code)
\begin{itemize}
\item keyed hash-function (hash-value is signed)
\item ensures data integrity and data authentication
\end{itemize}
MDC (Modification Detection Code)
\begin{itemize}
\item unkeyed hash-function
\item ensure data integrity
\end{itemize}

\subsubsection{\textbf{What is the meaning of ``pre-image resistance''? For what cryptographic primitive is it relevant?}}
It should be computationally unfeasible, to find a pre-image to a given hash-value, this is relevant for MDCs (Modification Detection Codes). 
So it should be efficiently possible, to find the pre-image of a hash-value, meaning, finding a value that is mapped to a certain hash value. 

\subsubsection{\textbf{Explain how RSA encryption and decryption work!}}
Shown in (\ref{ex:rsa}). 

\subsubsection{\textbf{What is a digital signature with appendix?}}
A digital signature binds someones identity to a piece of information, those with appendix require the original message as input to the verification algorithm. 

\subsubsection{\textbf{Describe and explain the Diffie-Hellman Problem? What is it used for?}}
It is used for RSA, generally used for computing a common secret key. Two entities A and B agree to use a prime number $p$ and a base $g$, now A generates a secret random number $a$ and B $b$. Then A sends $g^{a} \ mod \ p$ and B sends $g^{b} \ mod \ p$ and both can compute $g^{ab} \ mod \ p$, which is their common secret key. 

\subsubsection{\textbf{Name and explain at least three different models of security}}
Shown in (\ref{ex:secmod}).

\subsubsection{\textbf{What does the term ``exhaustive key search'' mean?}}
All keys in the key space are being tried out, until the correct one is found. 




%-----------------------------------------------------------
%-
%-  ELECTRONIC SIGNATURES and PUBLIC KEY INFRASTRUCTURES
%-
%-----------------------------------------------------------
\section{\textbf{ELECTRONIC SIGNATURES and PUBLIC KEY INFRASTRUCTURES}}
\subsection{\textbf{Digital Signatures}}
A \textbf{digital signature} is a data string, which associates a message in digital form with some originating entity. \\
\textbf{DS with appendix} require the original message as input \\
\textbf{DS with message recovery} do not require the original message as input, the message is recovered from the signature itself.\\
\textbf{Randomized DS} has several valid signatures for a given message. \\
Most of the signatures schemes which are in use today, belong to the class of (randomized) digital signatures with appendix, this is due to the fact, that in most schemes, the hash of a message is signed instead of the message. 
This has advantages, the signatures are much shorter, when the hash is signed and several attacks, which apply for signatures schemes with message recovery can be thwarted (vereitelt) by signing the hash. Breaks can be classified as
\begin{itemize}
\item \textbf{Total break}: An adversary is either able to compute the private key or find an efficient signing algorithm, which is functionally equivalent to the valid signing algorithm
\item \textbf{Selective forgery}: An adversary is able to create a valid signature for a particular message or a class of messages a priori, creating the signature does not involve directly the legitimate signer.
\item \textbf{Existential forgery}: An adversary is able to forge a signature for at least one message, there is little or no control over the message and the legitimate user may be involved in the deception. 
\end{itemize}
Attacks can be classified to the capabilities of the attacker
\begin{itemize}
\item \textbf{Key-only attack}: Adversary knows signer's public key
\item \textbf{Known-message attacks}: Adversary has signatures for a set of messages, which are known to him.
\item \textbf{Chosen-message attacks}: Adversary obtains valid signatures from a set of messages, chosen by him. 
\item \textbf{Adaptive chosen-message attack}: Adversary may request signatures which depend on the signer's public key and he may request signatures, which depend on previously obtained signatures. 
\end{itemize}

\vspace{0.5cm}
\subsubsection{\textbf{RSA Signature Scheme}}
Key setup is the same as in RSA encryption, $m$ denotes the input message, $n$ the modulus, $d$ the private key and $e$ the public key.\\
\begin{table}[h!]
  \begin{center}
    \begin{tabularx}{\columnwidth}{ l   }
    \toprule
    \textbf{Algorithm 1} RSA Signature Creation \\ \midrule
    \textbf{Input:} $m,n,d$ \\ 
    \textbf{Output:} $Sig(m)$ \\
 1.) $M = Encode (m)$ \\
 2.) $s = M^{d} \ mod \ n$ \\
 3.) return $s$ \\

    \bottomrule
    \end{tabularx}
  \end{center}
\end{table}

\pagebreak
\begin{table}[h!]
  \begin{center}
    \begin{tabularx}{\columnwidth}{ l   }
    \toprule
    \textbf{Algorithm 2} RSA Verification Creation \\ \midrule
    \textbf{Input:} $m,s,e$ \\ 
    \textbf{Output:} Accept/Reject \\
    1.) Check length of $s$, if invalid then Return \emph{Reject} \\
    2.) $M = s^{e} \ mod \ n$ \\
    3.) If $M=Encode(m)$, then Return \emph{Accept}, else \emph{Reject} \\
    \bottomrule
    \end{tabularx}
  \end{center}
\end{table}


\vspace{0.5cm}
\subsubsection{\textbf{DSA Signature Standard (DSS)}}
It requires the usage of a hash function, originally SHA-1 was required, but now other hash functions are also allowed. \\
The numbers created by the key generations algorithm are the two primes $p$ and $q$, the element $\alpha$ with order $q$, the private key $x$ and the corresponding public key $y$.
\begin{table}[h!]
  \begin{center}
    \begin{tabularx}{\columnwidth}{ l   }
    \toprule
    \textbf{Algorithm 3} DSA Key Generation \\ \midrule
    \textbf{Input:}  \\ 
    \textbf{Output:} $p,q,\alpha,x,y,g$ \\
    1.) Choose prime $q$ such that $2^{N-1} < q < 2^{N}$ \\
    2.) Select another prime $p$ such that $2^{L-1} < q < 2^{L}$ and with the \\
    property that $q|(p-1)$ \\
    3.) Choose $\alpha$ of order $q$, it holds then that $\alpha = g^{(p-1)/q}$ \\
    4.) Choose a random integer $x$ such that $1 \leq x \leq q-1$ \\
    5.) Compute $y = a^{x} \ mod \ p$ \\
    6.) Return public key ($p,q,\alpha,y$) and private key $x$\\
    \bottomrule
    \end{tabularx}
  \end{center}
\end{table}

\begin{table}[h!]
  \begin{center}
    \begin{tabularx}{\columnwidth}{ l   }
    \toprule
    \textbf{Algorithm 4} DSA Signature Creation \\ \midrule
    \textbf{Input:} $m,x$ \\ 
    \textbf{Output:} Sig(m) \\
    1.) Choose a random $k$, $0 < k < q$ \\
    2.) Compute $r = (a^k \ mod \ p) \ mod \ q$ \\
    3.) Compute $s = k^{-1}(h(m) + xr) \ mod \ q$ \\
    4.) Return the signature for $m$ which is $(r,s)$\\
    \bottomrule
    \end{tabularx}
  \end{center}
\end{table}

\begin{table}[h!]
  \begin{center}
    \begin{tabularx}{\columnwidth}{ l   }
    \toprule
    \textbf{Algorithm 5} DSA Signature Verification \\ \midrule
    \textbf{Input:} $m,(r,x),y$ \\ 
    \textbf{Output:} Accept/Reject \\
    1.) Verify that $0 < r < q$ and $0 < s < q$\\
    2.) Compute $u_1 = wh(m) \ mod \ q$ and $u_2 = rw \ mod \ q$ with \\ $w = s^{-1} \ mod \ q$ \\
    3.) Compute $v = (\alpha^{u_1}y^{u_2} \ mod \ p) \ mod \ q$ \\
    4.) Return the signature for $m$ which is $(r,s)$\\
    5.) Return \emph{Accept}, if $v=r$, otherwise return \emph{Reject}. \\
    \bottomrule
    \end{tabularx}
  \end{center}
\end{table}


\vspace{0.5cm}
\subsubsection{\textbf{ECDSA Signature Scheme}}
The elliptic curve digital signature algorithm (ECDSA) is the analogue to the DSA, the major difference is, that the DLP, which gives the algorithm its security, is hereby defined over an elliptic curve. 
Two entities choose a finite field $\mathbb{F}_q$, an elliptic curve E, defined over that field and a base point G with order n. One key pair is $(d,Q)$, where $d$ is her private and $Q$ is her public key. 

\begin{table}[h!]
  \begin{center}
    \begin{tabularx}{\columnwidth}{ l   }
    \toprule
    \textbf{Algorithm 6} ECDSA Signature Creation \\ \midrule
    \textbf{Input:} $m,d$, elliptic curve with base point $G$ of order $n$ \\ 
    \textbf{Output:} Accept/Reject \\
    1.) Chosse a random number $k$ with $k: 1 \leq k \leq n-1$\\
    2.) Compute $kG = (x_1,y_1)$ and $r = x_1 \ mod \ n$. If $r=0$,\\ then go to step 1. \\
    3.) Compute $k^{-1} \ mod \ n$ \\
    4.) $e = h(M)$ \\
    5.) Compute $s = k^{-1}(e+dr) \ mod \ n$. If $s=0$, then go to step 1. \\
    6.) Return the signature which is $(r,s)$ \\
    \bottomrule
    \end{tabularx}
  \end{center}
\end{table}
\begin{table}[h!]
  \begin{center}
    \begin{tabularx}{\columnwidth}{ l   }
    \toprule
    \textbf{Algorithm 7} ECDSA Signature Verification \\ \midrule
    \textbf{Input:} $m,(r,s),Q$, elliptic curve \\ 
    \textbf{Output:} Accept/Reject \\
    1.) Verifiy, that $r,s$ are integers in the intervall $[1,n-1]$ \\
    2.) compute $e = h(M)$ \\
    3.) Compute $w = s^{-1} \ mod \ n$ \\
    4.) Compute $u_1 = ew \ mod \ n $ and $u_2 = rw \ mod \ n$ \\
    5.) Compute $X = u_1G + u_2G$ \\
    6.) \textbf{if} $X=0$ \textbf{then} \\
    7.) 	  Return Reject \\
    8.) \textbf{else} \\
    9.) Compute $v=x_1 \ mod \ n$ where $X=(x_1,y_1)$ \\
    10.) Return Accept if $v=r$, else return Reject!\\
    \bottomrule
    \end{tabularx}
  \end{center}
\end{table}


\subsection{\textbf{Public Key Infrastructures}}
Even public keys need protection, because adversaries could try to modify published public keys. 
So there needs to be some mechanism to check their authenticity, meaning to check, if a certain key belongs indeed to a certain person. 
A public key infrastructure (PKI) is the basis of a security infrastructure, whose services are implemented and delivered by using public-key concepts and techniques. 
\vspace{0.5cm}
\subsubsection{\textbf{Public Key Distribution}}
Different possibilities for distributing public keys include the \emph{face-to-face approach}, isn't practical, the person would need to meet with everyone who wishes to obtain her public key in person. \\
The second option is, that the person publishes her key on a trusted web server and anyone, who wishes to obtain the key simply looks there. Is still impractical, because there is no way to verify the identity and integrity of the key. \\
The third option is, that the certified public key is stored on a trusted web server, meaning that the trusted web server provides a service, which adds additional information to a key, the so-called \textbf{certificate}.
A certificate basically consists of a public key and some user information, which has been digitally signed by the issuer of the certificate. 
\vspace{0.5cm}
\subsubsection{\textbf{PGP}}
In a PGP based PKI, each user acts a s a third party, who can sign keys. Each user also manages keys herself, hence, there is no need for a central controlling authority, it is based on the so-called \textbf{user-centric trust model}. Each user trusts herself and a limited amount of other users. 
For example, Alice trusts Bob, hence she trusts all the keys, which have been signed by Bob, so if Bob trusts Clark, then also Alice trusts Clark. \\
The problem here is, that it is implicitly assumed, that \textbf{trust is transitive}, also the \textbf{revocation} (Widerruf) is difficult. 
\vspace{0.5cm}
\subsubsection{\textbf{X.509}}
The trust model, which is the basis for X.509-based PKIs is the hierarchical trust model, there exists a so-called \textbf{root CA}, which acts as root or anchor of trust for the entire domain of entities below it, it owns a root-certificate, which is the basis of trust for all entities, that belong to the domain. The root CA certifies CAs immediately below it, who certify again some CAs below them and so on. \\
At the second to last level, the CAs certify end entities. \textbf{Each entity in the hierarchy} must be \textbf{supplied with the certificate of the root CA}. \\
The advantage is, that because of the hierarchical structure, revocation checking can be reliably implemented, disadvantages are, that they tend to be big and complex.

\vspace{0.5cm}
\subsubsection{\textbf{X.509 Certificates}}
A certificate is a data structure, which essentially \textbf{consists of the public key} of an entity \textbf{plus some information about the entity}, and it is \textbf{digitally signed} by the certificate issuer. 
\begin{figure}[h!]
\centering
\includegraphics[scale=0.44]{images/diagrams/x509.jpg} 
\end{figure}

\pagebreak

An \textbf{OID} is a unique representation for a given object, for example an algorithm or a standard, it is represented as a sequence of integers separated by decimal points. They are hierarchical and they are registered with authorities to ensure uniqueness. \\
A \textbf{DN} is a hierarchical naming convention, they are supposed to ensure the unique name of an entity and are expressed as a concatenation of relative DNs from toe top-level node down to the last node of DN. 

\subsubsection{\textbf{X.509 PKI Components}}
\begin{itemize}
\item \textbf{Registration Authority (RA)}: Often, a separate registration authority is used to verify the identity of entities. For highly trusted certificates, the verification of the identity requires physical presence of the entity.
\item \textbf{Certification Authority (CA)}: The certification authority issues certificates to entities, which have already been identified. 
\item \textbf{Certificate Repository}: The certificates are stored in the certificate repository, those can be implemted using LDAP (lightweight directory access protocol).
\item \textbf{Certificate Revocation}: The revocation of issued certificates is hardly implemented in practice, instead, most mechanisms are focused on the distribution of revocation information. 
\end{itemize}


\vspace{0.5cm}
\subsection{\textbf{Legal Aspects of Electronic Signatures}}
The legal definition of an electronic signature is given as follows
\begin{center}
\textit{Data in electronic form, which are attached to or logically associated with other electronic data and which serve as a method of authentication.}
\end{center}
According to the above mentioned directive, the validity of this electronic signature cannot be denied solely based on the fact, that it is in electronic form. 

\subsubsection{\textbf{Advanced Electronic Signatures}}
\label{sig:adv}
An \emph{advanced electronic signature} must be uniquely linked to the signatory (Unterzeichner). It also must be capable of identifying the signatory and must be created using means, that the signatory can maintain under his sole control. It also must be linked to the data, to which it relates, in such a manner, that any subsequent change of the data is detectable. \\
This type of electronic signatures are not considered equal to handwritten signatures from a legal point of view. 

\subsubsection{\textbf{Qualified (Secure) Electronic Signatures}}
A \emph{qualified (secure) electronic signature} is an advanced electronic signature, which was produced on a secure signature creation device and which is based on a qualified certificate. It must be assured, that the signature creation data (private key) exists only once and is protected by the user. \\
The Austrian Signature Law (SigG) specifies that, apart from a few exceptions, a qualified digital signature is legally equivalent to a handwritten signature. 


\pagebreak
\subsection{\textbf{Electronic Signatures in Practice}}
Applications, that profit from electronic signatures, are primarily available in the e-government sector. 
The Austrian initiative is known as the concept "Bürgerkarte", in this concept, the so-called "Bürgerkartenumgebung" is the combination of the security-relevant components with respect to electronic signatures, applications communicate with the Bürgerkartenumgebung over the so-called \textbf{security layer}, which is an interface, that provides a logical view. 



\subsection{\textbf{Review Exercises}}
\subsubsection{\textbf{What is a digital signature?}}
In the language of cryptographers, a \emph{digital signature} is a data string, which associates a message in digital form with some originating entity. 
\subsubsection{\textbf{What classes of digital signatures can you distinguish?}}
\begin{itemize}
\item DS with appendix
\item DS with message recovery
\item Randomized DS
\end{itemize}
\subsubsection{\textbf{What types of breaks of digital signatures schemes can you distinguish?}}
\begin{itemize}
\item \textbf{Total break}: An adversary is either able to compute the private key or find an efficient signing algorithm, which is functionally equivalent to the valid signing algorithm
\item \textbf{Selective forgery}: An adversary is able to create a valid signature for a particular message or a class of messages a priori, creating the signature does not involve directly the legitimate signer.
\item \textbf{Existential forgery}: An adversary is able to forge a signature for at least one message, there is little or no control over the message and the legitimate user may be involved in the deception. 
\end{itemize}
\subsubsection{\textbf{Describe the working principle of a digital signature scheme with appendix!}} 
Signatures with appendix require the message as input for the verification.
\subsubsection{\textbf{What is a PKI used for?}} 
PKI stands for Public Key Infrastructure, when using asymmetric encryption, the public keys have to be exchanged which can happen over a trusted web server. Besides the key there is also a certificate available, that guaranties, that the key hasn't been altered. 
\subsubsection{\textbf{What is the difference between a PGP-based and a X.509-based PKI?}} 
Difference lies in the trust modell.\\
\textbf{PGP}: Each user acts as CA and signs keys from other users, a user centric trust, if A trusts B and B trusts C, A also trusts C. \\
\textbf{X.509}: Hierarchical structure, root CA creates root certificate, can define some CAs below him, which also can certify CAs below them and so on, the second to last defines the end user. 
\subsubsection{\textbf{What is a CRL?}} 
A CRL (Certificate Revocation List) is a list of certificates, that have been revoked (für ungültig erklärt worden). 

\pagebreak
\subsubsection{\textbf{What is an advanced electronic signature?}} 
\begin{itemize}
\item It must be uniquely linked to the signatory
\item It must be capable of identifying the signatory
\item It must be created using means, that the signatory can maintain under his sole control
\item It must be lined to the data, which it relates to, in such a manner, that any subsequent change of the data is detectable. 
\end{itemize}
\subsubsection{\textbf{What type of electronic signature is equivalent (from a legal point of view) to a handwritten signature?}} 
Qualified electronic signatures are equivalent to handwritten signatures.
\begin{itemize}
\item advanced electronic signatures based on
\item secure signature-producing-process and based on qualified certificate
\item mandatory requirements like a private key must only exist once
\item the requirements are protected from harmful access of others
\end{itemize}

\raggedbottom

\pagebreak
\section{\textbf{ELECTRONIC COMMERCE}}
Electronic commerce, is the business of buying and selling products, information or services electronically, those are mostly conducted using a credit or debit card. 
Typically, e-commerce merchants store cardholder information in databases to streamline the process, hence, containing thousands of payment card accounts. 

\subsection{\textbf{E-shopping}}
E-shopping is a \emph{multi-phase process}. In the first phase, the customer browses through products, selected goods are typically put into a shopping cart and at the end of this process, the customer is usually asked to proceed to check out. 
In the second phase, the customer selects the payment and delivery options and in the third phase the goods are delivered. \\
One of the most important factors for the success of e-business is having a secure and reliable system, this depends on who's asking the question. 

\subsection{\textbf{Types of Payment}}
\textbf{Cash} is a floating claim on a bank or other financial institution, that is not linked to any particular account, it is a \emph{direct payment method}, it is well suited for occasional purchasing and for buying physical products but less suited for buying services, that are occur repeatedly. \\
Other types of payment systems are \textbf{checks} and \textbf{bank cards}. Checks are suitable for not to small payments, a disadvantage is the costly rejection of a check. \\
Bank cards are also suitable for any not too small value, the payee can be remote from the payer, many of those systems require only connections for verification nowadays. \\
\textbf{Credit systems} work differently, the customer has to register with a bank, if goods are purchased, they get debited on his account and the customer is only billded after a certain amount of time has passed or only once a month. \\
In a \textbf{debit system}, the customer pays before the purchase, such systems are suitable for subscriptions or any regular purchases. 

\subsection{\textbf{E-payments}}
\subsubsection{\textbf{E-money}}
\emph{E-money} or \textbf{digital currency} is simply an encoded string of digits and essentially consists of a serial number and the amount. 
It is a floating claim on a bank or other financial institution, that is not linked to any particular account. Expected Advantages are, that it is anonymous, and involved entities do not have to trust each other, and there follows the direct disadvantage, following the anonymity aspect, it is \textbf{not traceable}. \\
It is possible to distinguish \textbf{micropayments} and \textbf{macropayments}. \\
\textbf{Micropayments} are tiny value transactions below \$1, they are supposed to be cheap and a little cheating can be tolerated because of the minuscule amount. \\
\textbf{Macropayments} are medium value transactions (between \$1 and \$1000) and large value transactions (over \$1000). 
\label{tex:sect}
\begin{itemize}
\item \textbf{Security}: It is mandatory to prevent forgery, double spending and collusion of other parties (multi-party security)
\item \textbf{Acceptability}: A wide range of parties needs to accept the payments
\item \textbf{Convenience}: Factors that increase the convenience are speed, reliability, divisibility and transferability.
\item \textbf{Cost}: Virtually no cost should arise while dealing with digital currency, as it is with physical currency. 
\item \textbf{Privacy}: Cash is the most anonymous payment form, e-money should be as well. 
\item \textbf{Durability}: E-money shouldn't be easily lost, like during a system crash
\item \textbf{Independence}: E-money should be easily storable on different devices
\item \textbf{Transferability}: Cash can be easily exchanged between entities, should be the same for e-money.
\item \textbf{Divisibility}: Customer gets return money, if price is lower than the given amount in the physical world, should be the same for e-money.
\item \textbf{Immediate Control}: In case of a security breach, such as forgery of money, it must be possible to identify the security breach immediately. 
\item \textbf{Traceability}: Especially with large transactions, anonymous money can be a problem, some sort of tracing mechanism would be an advantage.
\item \textbf{Spread of Encryption Mechanisms}: E-money systems, which involve encryption heavily, might be difficult to export to other countries. 
\end{itemize}
Trade-offs include \label{tex:tradeoff}
\begin{itemize}
\item \textbf{Privacy vs Traceability}: Tiny value payments deserve to be anonymous, while for large value payments traceability is probably favourable. 
\item \textbf{On-line vs Off-line}: On-line payments allow to prevent double spending easily and simplify tracing transactions. Offline payments often use special purpose hardware to prevent double spending.
\item \textbf{Hardware vs Software}: Hardware solutions can also prevent double spending, but often hardware decrease the customer acceptance. 
\item \textbf{Transparency vs Explicitness}: User want to have control over all their transactions but they also expect not to be bothered with any details. 
\end{itemize}
\vspace{0.5cm}
Discussed will be the famous DigiCash system, coins there are anonymous, so the bank doesn't know, which coin belongs to which customer. Despite the anonymity, the system prevents multiple spending of coins, it allows even to determine with a high probability, who tried to double-spend money in case such a fraud occurred. 
\pagebreak
The protocol, describing the DigiCash system works as follows:
\begin{itemize}
\item \textbf{Money Generation Phase}:\\ Customer produces $n$ money orders with $n$ serial numbers and $n$ identity strings, then the customer "blinds" the money orders, so the bank doesn't see the serial numbers, so it is anonymous. The bank now checks $n-1$ money orders for their consistency, if valid, it signs the last remaining blinded money order with its private key, without seeing what's inside, customer now possesses an anonymous coin signed by the bank.
\item \textbf{Money Spending Phase}: \\
Merchant check the validity of the coin by checking bank signature. Then requests halves of the identity strings, randomly either the left or right one of each identity string and stores them.
\item \textbf{Double-spending Checking Phase}: \\
When merchant now deposits coin at the bank, signature is once again validated and the database is checked for the serial number. If the string is already present, bank checks stored identity strings, if merchant wanted to collect money twice, those strings will match. Otherwise there will be a pair of identity string halves, that will produce a full identity string and reveal the cheating customer. 
\end{itemize}


\vspace{0.5cm}
\subsubsection{\textbf{Bank cards}}
Bank cards nowadays are often smart cards and offer two different functionalities: Maestro and Quick. Whenever money is being put on a Quick Card, the PIN must be entered and is checked by an online system, those transactions are authorized by this central system. 
In all Quick terminals, there is a smart card which is used for "offline" payments. This card communicates with the customer card, saves information about the turnover and can provide additional authentication mechanisms. 
\vspace{0.5cm}
\subsubsection{\textbf{SET and its Successors}}
SET stands for \textbf{Secure Electronic Transactions} and is a specification for authentication for paying with credit cards within online networks, jointly developed by VISA and MasterCard. \\
In SET, the cardholder uses a software called an electronic wallet, in which the credit card numbers and digital certificate are stored. The merchant acquires a digital certificate from a financial institution and both cardholder and merchant use their certificates for authentication before a transaction. 
During a SET transaction, the credit card number is not seen by the merchant, only the encrypted number is sent to the credit card issuer, which approves the transaction for the merchant. In this way, disclosure is prohibited during the transaction. \\
The cryptographic means to ensure the privacy of customer data, it is called \textbf{dual-signature}, it allows the cardholder to communicate with both the merchant and the bank with one single message, which contains an order section plus a payment section
\begin{itemize}
\item The merchant does not need to see the payment section.
\item The bank does not need to see the order section. 
\item But, both sections need to be bound together. 
\end{itemize}
The disadvantage of SET were the significant investment required for cardholder, merchant and bank, in the mean time SET was replaced by proprietary systems from VISA (3d-Secure) and MasterCard(Master Card SecureCode). 

\subsection{\textbf{Alternative E-payment Methods}}
\begin{itemize}
\item PayPal
\item PaySafe Card
\item First Gate Click\& Buy
\item Google Wallet and NFC
\end{itemize}
More information about those payment options in script starting on page 41.


\subsection{\textbf{Review Exercises}}

\subsubsection{\textbf{What types of payment systems can you distinguish?}}
\begin{itemize}
\item Cash
\item Credit systems
\item Debit systems
\end{itemize}

\subsubsection{\textbf{What is the difference between micropayments and macropayments?}}
Micropayments describe payments below 1\$ and macro payments usually payments between 1\$ and 1000\$. 
\subsubsection{\textbf{Discuss 4 aspects of digital currency!}}
Shown in (\ref{tex:sect}).
\subsubsection{\textbf{Discuss the trade-offs that are typically made in electronic payment systems!}}
Shown in (\ref{tex:tradeoff}).
\subsubsection{\textbf{Explain in short, how money is generated in the DigiCash system!}}
Answer is on the left side! :) Money Generation Phase of DigiCash. 
\subsubsection{\textbf{What does SET mean and what was/is the SET system used for?}}
SET stands for Secure Electronic Transaction and is a specification for paying with credit cards, used in the past by VISA and MasterCard.
\subsubsection{\textbf{Explain the purpose of the dual signature in the SET system!}}
It allows the cardholder a sensitive way to pay, without the merchant seeing the payment details and without the bank seeing the order details, each part is encrypted using either the public key of the merchant or the bank, but both are bound together. 


\pagebreak







\section{\textbf{NETWORK SECURITY}}

Network security addresses all security issues, which come into play when two parties attempt to communicate over a network, which is typically not secure and trusted. This part focuses on attacks and counter-measures, which are not prevented by cryptographic methods. 

\subsection{\textbf{Social Engineering}}

\subsection{\textbf{OS Fingerprinting}}

\subsubsection{\textbf{Telnet}}

\subsubsection{\textbf{TCP Stack Fingerprinting}}

\subsection{\textbf{Attacking Internet Protocols}}

\subsubsection{\textbf{SYN Flooding}}

\subsubsection{\textbf{Smurfing}}

\subsubsection{\textbf{DDoS Attacks}}

\subsubsection{\textbf{Spoofing}}

\subsection{\textbf{Trojans, Viruses, Worms and other malicious code}}

\subsubsection{\textbf{Taxonomy of Malicious Programs}}

\subsubsection{\textbf{Trap doors}}

\subsubsection{\textbf{Logic Bombs}}

\subsubsection{\textbf{Zombies}}

\subsubsection{\textbf{Viruses and Worms}}

\subsection{\textbf{Intrusion Detection and Firewalls}}

\subsubsection{\textbf{Firewalls}}

\subsubsection{\textbf{Intrusion Detection Systems}}



\subsection{\textbf{Review Exercises}}
\subsubsection{\textbf{What is social engineering?}}

\subsubsection{\textbf{What are the goals of social engineering?}}

\subsubsection{\textbf{What is OS Fingerprinting?}}

\subsubsection{\textbf{What is TCP stack fingerprinting}}

\subsubsection{\textbf{What is accomplished by a smurfing attack?}}

\subsubsection{\textbf{What is a trap door?}}

\subsubsection{\textbf{What are the four phases of a virus?}}

\subsubsection{\textbf{What types of viruses can you distinguish?}}

\subsubsection{\textbf{What is a firewall?}}

\subsubsection{\textbf{What types of intrusion detection systems can you distinguish?}}






\section{\textbf{IMPLEMENTATION SECURITY}}
\subsection{\textbf{Review Exercises}}






\section{\textbf{OPERATING SYSTEM SECURITY}}
\subsection{\textbf{Review Exercises}}






\section{\textbf{PRIVACY}}
\subsection{\textbf{Review Exercises}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%-----------------------------------------------------------
%-
%-  Appendix
%-
%-----------------------------------------------------------
\section*{APPENDIX}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%





\end{document}
